import os

from datetime import date
from datetime import timedelta

from django.conf import settings
from django.core.management import call_command
from django.core.management.base import BaseCommand
from django.urls import reverse

from django_q.models import Schedule
from django_q.tasks import schedule

from flags.state import flag_enabled

from urllib.parse import urljoin

from coldfront.core.allocation.management.commands.audit_allocation_period import AuditFailure
from coldfront.core.utils.common import display_time_zone_date_to_utc_datetime
from coldfront.core.utils.common import utc_now_offset_aware
from coldfront.core.utils.mail import send_email_template

import logging


logger = logging.getLogger(__name__)


# If an audit fails or raises an error, retry it in X days.
RERUN_FAILED_AUDIT_DELAY_DAYS = 3


class Command(BaseCommand):

    help = (
        'Schedule an audit of each of the AllocationPeriods associated '
        'with the current year.')

    def add_arguments(self, parser):
        parser.add_argument(
            'email',
            help=(
                'A space-separated list of email addresses to send result '
                'notifications generated by audits to.'),
            nargs='+',
            type=str)
        parser.add_argument(
            '--schedule',
            action='store_true',
            default=False,
            help='Schedule this command to run once a year.')
        parser.add_argument(
            '--month',
            default=1,
            help=(
                'A number from 1 - 12 denoting a month. The command will run '
                'on the first day of the specified month.'),
            type=int)

    def handle(self, *args, **options):
        if options['schedule']:
            self._handle_schedule(options['month'], options['email'])
        else:
            self._handle_synchronous(options['email'])

    @staticmethod
    def _get_allocation_period_names_to_audit(year):
        """Return a list of names (strs) of AllocationPeriods to
        audit for the given year."""
        allocation_period_names = [
            f'Allowance Year {year} - {year + 1}',
        ]

        if flag_enabled('BRC_ONLY'):
            allocation_period_names.extend([
                f'Fall Semester {year}',
                f'Spring Semester {year + 1}',
                f'Summer Sessions {year + 1} - Session A',
                f'Summer Sessions {year + 1} - Session B',
                f'Summer Sessions {year + 1} - Session C',
                f'Summer Sessions {year + 1} - Session D',
                f'Summer Sessions {year + 1} - Session E',
                f'Summer Sessions {year + 1} - Session F',
            ])

        return allocation_period_names

    def _handle_schedule(self, month, emails):
        """Schedule the audits to run on the first day of the given
        month (int), the next time that date occurs. The audits will
        send results to the given email addresses."""
        if month not in range(1, 12 + 1):
            raise ValueError('Month must be a number from 1 - 12.')

        func = 'django.core.management.call_command'
        command_name = __name__.rsplit('.', maxsplit=1)[-1]
        args = (command_name, '--email', *emails)

        next_run = self._next_instance_of_date(month, 1)
        kwargs = {
            'schedule_type': 'Y',
            'next_run': next_run,
        }

        schedule(func, *args, **kwargs)

    def _handle_synchronous(self, emails):
        """Schedule the audits to run immediately."""
        year = utc_now_offset_aware().year
        allocation_period_names = self._get_allocation_period_names_to_audit(
            year)
        for allocation_period_name in allocation_period_names:
            schedule_args = (allocation_period_name, '--email', *emails)
            audit_task_scheduled = self._schedule_audit_task_if_not_scheduled(
                *schedule_args)
            if not audit_task_scheduled:
                message = (
                    f'An audit for AllocationPeriod "{allocation_period_name}" '
                    f'is already scheduled.')
                self.stdout.write(self.style.WARNING(message))

    @staticmethod
    def _next_instance_of_date(month, day):
        """Return a timezone-aware datetime representing the next
        instance of the date that the given month and day
        comprise."""
        now = utc_now_offset_aware()
        year = now.year

        date_this_year = display_time_zone_date_to_utc_datetime(
            date(year, month, day))
        if now >= date_this_year:
            return display_time_zone_date_to_utc_datetime(
                date(year + 1, month, day))
        return date_this_year

    @staticmethod
    def _schedule_audit_task_if_not_scheduled(*args, task_next_run=None):
        """Schedule a run of the `audit_allocation_period` command for
        each of the AllocationPeriods, passing to it the given args.
        Optionally schedule the audits to run at a specified time, else
        immediately.
        
            - The audit for a period P is only scheduled if an audit
              for P is not already scheduled. Return whether an audit
              was scheduled.
            - If the scheduled audit fails or raises an error, a Django
              Q hook schedules a new audit to run in
              RERUN_FAILED_AUDIT_DELAY_DAYS.

        """

        def clean_period_name(period_name):
            return period_name.lower().replace('-', '').replace(' ', '_')

        allocation_period_name = args[0]
        cleaned_period_name = clean_period_name(allocation_period_name)
        task_name = f'audit_allocation_period_{cleaned_period_name}'

        if Schedule.objects.filter(name=task_name).exists():
            return False

        func = f'{__name__}.call_audit_command'
        hook = f'{__name__}.audit_command_task_hook'
        kwargs = {
            'name': task_name,
            'hook': hook,
            'schedule_type': 'O',
        }
        if task_next_run is not None:
            kwargs['next_run'] = task_next_run

        schedule(func, *args, **kwargs)

        return True


    @staticmethod
    def _send_audit_exception_email(allocation_period_name, task, emails):
        """Send an email to the given set of email addresses, notifiyng
        them that the audit did not finish due to an error."""
        subject = (
            f'AllocationPeriod "{allocation_period_name}" Audit: Exception')

        template_dir = 'email/audit_allocation_period'
        template_base_name = 'audit_exception'
        template_name = os.path.join(template_dir, f'{template_base_name}.txt')
        html_template = os.path.join(template_dir, f'{template_base_name}.html')

        task_url = urljoin(
            settings.CENTER_BASE_URL,
            reverse('admin:django_q_failure_change', args=[task.id]))
        context = {
            'allocation_period_name': allocation_period_name,
            'task_url': task_url,
        }

        sender = settings.EMAIL_SENDER
        receiver_list = emails

        send_email_template(
            subject, template_name, context, sender, receiver_list,
            html_template=html_template)


def audit_command_task_hook(task):
    """A Django Q hook that re-schedules the given audit task in
    RERUN_FAILED_AUDIT_DELAY_DAYS, if the task did not complete due to
    an exception, or the audit failed."""
    task_next_run = (
        utc_now_offset_aware() +
        timedelta(days=RERUN_FAILED_AUDIT_DELAY_DAYS))

    allocation_period_name = task.args[0]

    if not task.success:
        # Re-enqueue the audit for the same period in X days.
        Command._schedule_audit_task_if_not_scheduled(
            *task.args, task_next_run=task_next_run)
        if len(task.args) > 1 and task.args[1] == '--email':
            # TODO: If new parameters are added, this check needs to be
            #  revised because '--email' may come before or after other
            #  optional arguments.
            emails = task.args[2:]
            Command._send_audit_exception_email(
                allocation_period_name, task, emails)
    else:
        audit_succeeded = bool(task.result)
        if not audit_succeeded:
            # Re-enqueue the audit for the same period in X days.
            Command._schedule_audit_task_if_not_scheduled(
                *task.args, task_next_run=task_next_run)


def call_audit_command(*args, **kwargs):
    """Call `audit_allocation_period`. Return whether the audit
    succeeded. Re-raise any exception."""
    try:
        call_command('audit_allocation_period', *args, **kwargs)
    except AuditFailure as e:
        logger.warning(f'The audit of AllocationPeriod "{args[0]}" failed.')
        return False
    except Exception as e:
        logger.exception(e)
        raise e
    return True
